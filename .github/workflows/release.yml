name: Release

on:
  push:
    tags: ['v*']
  workflow_dispatch:
    inputs:
      publish_crates:
        description: 'Publish to crates.io (set true to run the publish job)'
        required: true
        type: boolean
        default: false

      # Simple per-crate checkboxes (select/deselect)
      publish_atm_core:
        description: 'Publish crate: atm-core'
        required: false
        type: boolean
        default: true
      publish_atm_protocol:
        description: 'Publish crate: atm-protocol'
        required: false
        type: boolean
        default: true
      publish_atm_tui:
        description: 'Publish crate: atm-tui'
        required: false
        type: boolean
        default: true
      publish_atmd:
        description: 'Publish crate: atmd'
        required: false
        type: boolean
        default: true
      publish_atm:
        description: 'Publish crate: atm (root)'
        required: false
        type: boolean
        default: true

      include_deps:
        description: 'Include workspace dependencies of selected crates'
        required: false
        type: boolean
        default: true
      dry_run:
        description: 'Run cargo publish --dry-run'
        required: false
        type: boolean
        default: false

permissions:
  contents: write

env:
  CARGO_TERM_COLOR: always

jobs:
  publish:
    name: Publish to crates.io
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.publish_crates == 'true'

    env:
      CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-toolchain@stable

      - name: Calculate publish order (original order + checkboxes)
        id: calc
        run: |
          set -euo pipefail
          python3 - <<'PY'
import os, subprocess, json, sys

ORIGINAL_ORDER = [
    'atm-core',
    'atm-protocol',
    'atm-tui',
    'atmd',
    'atm',
]

checkbox_map = {
    'publish_atm_core': 'atm-core',
    'publish_atm_protocol': 'atm-protocol',
    'publish_atm_tui': 'atm-tui',
    'publish_atmd': 'atmd',
    'publish_atm': 'atm',
}

with open(os.environ['GITHUB_EVENT_PATH']) as f:
    event = json.load(f)

selected = {
    name
    for box, name in checkbox_map.items()
    if str(event.get('inputs', {}).get(box, 'false')).lower() == 'true'
}

include_deps = str(event.get('inputs', {}).get('include_deps', 'true')).lower() == 'true'
dry_run = str(event.get('inputs', {}).get('dry_run', 'false')).lower() == 'true'

if not selected:
    print('::error::No crates selected')
    sys.exit(1)

if not include_deps:
    final_order = [p for p in ORIGINAL_ORDER if p in selected]
else:
    meta = json.loads(subprocess.check_output(['cargo', 'metadata', '--format-version=1'], text=True))
    workspace_ids = set(meta['workspace_members'])
    id_to_name = {p['id']: p['name'] for p in meta['packages']}
    workspace_names = {id_to_name[i] for i in workspace_ids}

    deps = {}
    for p in meta['packages']:
        if p['id'] in workspace_ids:
            deps[p['name']] = {
                d['name'] for d in p['dependencies'] if d['name'] in workspace_names
            }

    final_set = set(selected)
    stack = list(selected)
    while stack:
        c = stack.pop()
        for d in deps.get(c, []):
            if d not in final_set:
                final_set.add(d)
                stack.append(d)

    visited = {}
    order = []

    def dfs(n):
        if visited.get(n) == 1:
            raise RuntimeError('dependency cycle detected')
        if visited.get(n) == 2:
            return
        visited[n] = 1
        for d in deps.get(n, []):
            if d in final_set:
                dfs(d)
        visited[n] = 2
        order.append(n)

    for n in ORIGINAL_ORDER:
        if n in final_set:
            dfs(n)

    final_order = order

with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
    f.write(f"publish_names={','.join(final_order)}\n")
    f.write(f"dry_run={'true' if dry_run else 'false'}\n")
PY

      - name: Publish crates
        run: |
          IFS=',' read -r -a pkgs <<< "${{ steps.calc.outputs.publish_names }}"
          for p in "${pkgs[@]}"; do
            if [ "${{ steps.calc.outputs.dry_run }}" = 'true' ]; then
              cargo publish -p "$p" --dry-run
            else
              cargo publish -p "$p"
            fi
            sleep 20
          done
